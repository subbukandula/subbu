fileName = args[0];
final String regularExpression = "([\\w\\:\\\\w ./-]+\\w+(\\.)?\\w+)";
Pattern pattern = Pattern.compile(regularExpression);
boolean isMatched = pattern.matcher(fileName).matches();


<!-- Interceptors extend e.g. 
       org.apache.cxf.phase.AbstractPhaseInterceptor -->
  <bean id="anotherInterceptor" class="..." />
 
  <!-- Handlers implement e.g. javax.xml.ws.handler.soap.SOAPHandler -->
  <bean id="jaxwsHandler" class="..." />
 
  <!-- The SOAP client bean -->
  <jaxws:client id="helloClient"
                serviceClass="demo.spring.HelloWorld"
                address="http://localhost:9002/HelloWorld">
    <jaxws:inInterceptors>
      <bean class="org.apache.cxf.interceptor.LoggingInInterceptor"/>
      <ref bean="anotherInterceptor"/>
    </jaxws:inInterceptor>
    <jaxws:handlers>
      <ref bean="jaxwsHandler" />
    </jaxws:handlers>
    <jaxws:properties>
      <entry key="mtom-enabled" value="true"/>
    </jaxws:properties>
  </jaxws:client>


private void validateReturnPage(String pageUrl, HttpServletRequest req) throws MalformedURLException
{
if (pageUrl.indexOf(':') != -1)
{ // ':' only allowed in a URL as part of a scheme prefix 
throw new IllegalArgumentException("The redirect URL doesn't support absolute URls"); }
// Evaluate it relative to the request URL and strip out .. and .
pageUrl = new URL(new URL(req.getRequestURL().toString()), pageUrl).getPath();
if (!pageUrl.startsWith(req.getContextPath()))
{ throw new IllegalArgumentException("The redirect URL must be in the same context."); 
}
}




Log forging

If you really need less code then I'd suggest you to do a helper
public static String[] htmlEscape(final String... args) {
     return Arrays.stream(args)
                  .map(HtmlUtil::htmlEscape)
                  .toArray(String[]::new);
}
And use it this way
if (logger.isInfoEnabled()) {
    logger.info("call  idn:{}, agentNo={}", htmlEscape(idn, agentNo));
}
Note a call to isInfoEnabled. It prevents you from doing unnecessary arguments escaping if INFO loglevel is disabled. You can reduce this cpu overhead by a bit increased memory usage by using this tricky way to make it htmlEscape lazy evaluated
public static Object[] lazyHtmlEscape(final String... args) {
     return Arrays.stream(args)
                  .map(arg -> new Object {
                      @Override
                      public String toString() {
                          // here argument will be escaped only if
                          // toString method will be called
                          // (that happens if loglevel is enabled)
                          return HtmlUtil.htmlEscape(e);
                      }
                  })
                  .toArray();
}
logger.info("call  idn:{}, agentNo={}", lazyHtmlEscape(idn, agentNo));


@FortifyValidate("return")
private String sanitizeString(String taintedString) {
    return doSomethingWithTheString(taintedString);
}


private cleanLogString(String logString) {
    String clean = logString.replaceAll("[^A-Za-z0-9]", "");

    if(!logString.equals(clean)) {
        clean += " (CLEANED)";
    }

    return clean;
}
